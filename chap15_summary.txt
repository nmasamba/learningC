
Hash table is a data structure in which keys are
mapped to array positions by a hash function. A value
stored in a hash table can be searched in O(1) time
using a hash function which generates an address
from the key.
∑ The storage requirement for a hash table is O(k),
where k is the number of keys actually used. In a
hash table, an element with key k is stored at index
h(k), not k. This means that a hash function h is used
to calculate the index at which the element with key
k will be stored. Thus, the process of mapping keys
to appropriate locations (or indices) in a hash table
is called hashing.
∑ Popular hash functions which use numeric keys are
division method, multiplication method, mid square
method, and folding method.
∑ Division method divides x by M and then uses the
remainder obtained. A potential drawback of this
method is that consecutive keys map to consecutive
hash values.
∑ Multiplication method applies the hash function
given as h (x) = Î m (kA mod 1) ˚
∑ Mid square method works in two steps. First, it finds
k2 and then extracts the middle r digits of the result.
∑ Folding method works by first dividing the key value
k into parts k1
, k2
, ..., kn
, where each part has
the same number of digits except the last part which
may have lesser digits than the other parts, and then
obtaining the sum of k1
 + k2
 + ... + kn
. The hash
value is produced by ignoring the last carry, if any.
∑ Collisions occur when a hash function maps two
different keys to the same location. Therefore, a
method used to solve the problem of collisions, also
called collision resolution technique, is applied. The
two most popular methods of resolving collisions
are: (a) open addressing and (b) chaining.
∑ Once a collision takes place, open addressing
computes new positions using a probe sequence and the next record is stored in that position. In this
technique of collision resolution, all the values are
stored in the hash table. The hash table will contain
two types of values—either sentinel value (for
example, –1) or a data value.
∑ Open addressing technique can be implemented
using linear probing, quadratic probing, double
hashing, and rehashing.
∑ In linear probing, if a value is already stored at a
location generated by h(k), then the following hash
function is used to resolve the collision:
h(k, i) = [h’(k) + i] mod m
Though linear probing enables good memory
caching, the drawback of this algorithm is that it
results in primary clustering.
∑ In quadratic probing, if a value is already stored at a
location generated by h(k), then the following hash
function is used to resolve the collision:
h(k, i) = [h’(k) + c1
i + c2
i2
] mod m
Quadratic probing eliminates primary clustering and
provides good memory caching. But it is still liable
to secondary clustering.
∑ In double hashing, we use two hash functions rather
than a single function. The hash function in the case
of double hashing can be given as:
h(k, i) = [h1
(k) + ih2
(k)] mod m
The performance of double hashing is very close
to the performance of the ideal scheme of uniform
hashing. It minimizes repeated collisions and the
effects of clustering.
∑ When the hash table becomes nearly full, the number
of collisions increases, thereby degrading the
performance of insertion and search operations. So
in rehashing, all the entries in the original hash table
are moved to the new hash table which is double the
size of the original hash table.
In chaining, each location in a hash table stores a
pointer to a linked list that contains all the key values
that were hashed to that location. While the cost of
inserting a key in a chained hash table is O(1), the cost
for deleting and searching a value is given as O(m),
where m is the number of elements in the list of that
location. However, in the worst case, searching for
a value may take a running time of O(n).